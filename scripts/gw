#!/usr/bin/env bash
set -euo pipefail

show_help() {
    cat << 'EOF'
Git worktree manager (sibling worktrees only)

Usage:
  gw new <name>      Create new worktree from main
  gw fork <name>     Create new worktree from current HEAD
  gw delete [name]   Delete current worktree (or named one)
  gw list            List all worktrees
  gw help            Show this help

Aliases:
  n=new, f=fork, d=delete, l=list, h=help

Environment:
  GW_USER            Username prefix for new branches (default: $USER)
  GW_CD_FILE         If set, gw writes target directory path to this file

Examples:
  gw new feature-auth
  gw fork split-current-task
  gw delete
  gw delete irakli-2026-02-12-feature-auth
EOF
}

# Helper to signal cd to wrapper (or print if no wrapper)
signal_cd() {
    if [ -n "${GW_CD_FILE:-}" ]; then
        echo "$1" > "$GW_CD_FILE"
    else
        echo "  cd $1"
    fi
}

# Get base directory name (strips --worktree suffix if present)
get_base_name() {
    local dir="$1"
    if [[ "$dir" == *"--"* ]]; then
        echo "${dir%%--*}"
    else
        echo "$dir"
    fi
}

# Check if current worktree is the main one (no -- in name)
is_main_worktree() {
    local git_root
    git_root=$(git rev-parse --show-toplevel)
    local current_dir
    current_dir=$(basename "$git_root")
    [[ "$current_dir" != *"--"* ]]
}

run_install_quiet() {
    local worktree_path="$1"
    local manager="$2"
    shift 2

    if ! command -v "$manager" >/dev/null 2>&1; then
        echo "Deps: $manager not found, skipped"
        return 0
    fi

    local log_file
    log_file=$(mktemp -t "gw-${manager}-install-XXXXXX.log")

    if (cd "$worktree_path" && "$@") >"$log_file" 2>&1; then
        rm -f "$log_file"
        echo "Deps: $manager install done"
    else
        echo "Deps: $manager install failed (log: $log_file)"
        tail -n 40 "$log_file" || true
        return 1
    fi
}

cmd_create_from_base() {
    local base_ref="$1"
    local mode_name="$2"
    shift 2

    local name="${1:-}"

    if [ -z "$name" ]; then
        echo "Error: Branch name required"
        echo "Usage: gw ${mode_name} <name>"
        exit 1
    fi

    if [ "$#" -gt 1 ]; then
        echo "Error: gw ${mode_name} accepts only one argument"
        echo "Usage: gw ${mode_name} <name>"
        exit 1
    fi

    local git_root
    git_root=$(git rev-parse --show-toplevel)

    local current_dir
    current_dir=$(basename "$git_root")

    local base_name
    base_name=$(get_base_name "$current_dir")

    local parent_dir
    parent_dir=$(dirname "$git_root")

    local branch_name
    local worktree_path
    local is_existing_local=false
    local is_existing_remote=false

    if git show-ref --verify --quiet "refs/heads/$name" 2>/dev/null; then
        branch_name="$name"
        is_existing_local=true
    elif git ls-remote --heads origin "$name" 2>/dev/null | grep -q .; then
        branch_name="$name"
        is_existing_remote=true
    else
        branch_name="${GW_USER:-$USER}/$(date +%Y-%m-%d)-$name"
    fi

    local safe_branch_name="${branch_name//\//-}"
    worktree_path="${parent_dir}/${base_name}--${safe_branch_name}"

    local base_dir
    base_dir="${parent_dir}/${base_name}"

    if [ -d "$worktree_path" ]; then
        echo "Error: Directory already exists: $worktree_path"
        exit 1
    fi

    echo "Creating worktree..."

    if [ "$is_existing_local" = true ]; then
        git worktree add "$worktree_path" "$branch_name"
    elif [ "$is_existing_remote" = true ]; then
        git fetch origin "$branch_name:$branch_name" >/dev/null 2>&1 || true
        if git show-ref --verify --quiet "refs/heads/$branch_name" 2>/dev/null; then
            git worktree add "$worktree_path" "$branch_name"
        else
            git worktree add -b "$branch_name" "$worktree_path" "origin/$branch_name"
        fi
    else
        git worktree add -b "$branch_name" "$worktree_path" "$base_ref"
    fi

    if command -v direnv >/dev/null 2>&1; then
        direnv allow "$worktree_path" >/dev/null 2>&1 || true
    fi

    if [ -f "$base_dir/.env" ]; then
        cp "$base_dir/.env" "$worktree_path/.env"
        sed -i '/^BRANCH_HASH=/d' "$worktree_path/.env"

        local branch_hash
        branch_hash=$(printf '%s' "$branch_name" | md5sum | cut -c1-8)

        {
            echo ""
            echo "# Auto-generated for worktree isolation"
            echo "BRANCH_HASH=${branch_hash}"
        } >> "$worktree_path/.env"
    fi

    if [ -d "$base_dir/.pi" ] && [ ! -d "$worktree_path/.pi" ]; then
        cp -r "$base_dir/.pi" "$worktree_path/.pi"
    fi

    if [ -f "$worktree_path/pnpm-lock.yaml" ]; then
        run_install_quiet "$worktree_path" "pnpm" pnpm install
    elif [ -f "$worktree_path/bun.lockb" ] || [ -f "$worktree_path/bun.lock" ]; then
        run_install_quiet "$worktree_path" "bun" bun install
    elif [ -f "$worktree_path/package-lock.json" ]; then
        run_install_quiet "$worktree_path" "npm" npm install
    fi

    echo "Worktree ready: $worktree_path"
    echo "Branch: $branch_name"

    signal_cd "$worktree_path"
}

cmd_new() {
    cmd_create_from_base "main" "new" "$@"
}

cmd_fork() {
    cmd_create_from_base "HEAD" "fork" "$@"
}

cmd_delete() {
    local name="${1:-}"

    local git_root
    git_root=$(git rev-parse --show-toplevel)

    local current_dir
    current_dir=$(basename "$git_root")

    local base_name
    base_name=$(get_base_name "$current_dir")

    local parent_dir
    parent_dir=$(dirname "$git_root")

    local worktree_path

    if [ -z "$name" ]; then
        if is_main_worktree; then
            echo "Error: Cannot delete main worktree. Use 'gw delete <name>' to delete a specific worktree."
            exit 1
        fi
        worktree_path="$git_root"
    else
        worktree_path="$parent_dir/${base_name}--${name}"
        if [ ! -d "$worktree_path" ]; then
            echo "Error: Worktree '$name' not found at $worktree_path"
            echo "Available worktrees:"
            git worktree list
            exit 1
        fi
    fi

    local target_dir
    target_dir=$(basename "$worktree_path")
    if [[ "$target_dir" != *"--"* ]]; then
        echo "Error: Cannot delete main worktree"
        exit 1
    fi

    echo "Deleting worktree: $worktree_path"
    read -r -p "Are you sure? (y/N) " -n 1
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Aborted"
        exit 1
    fi

    local cd_target
    cd_target="$parent_dir/$base_name"

    git worktree remove "$worktree_path" --force
    echo "Worktree deleted"

    if [ "$worktree_path" = "$git_root" ]; then
        signal_cd "$cd_target"
    fi
}

cmd_list() {
    git worktree list
}

case "${1:-}" in
    n|new)
        shift
        cmd_new "$@"
        ;;
    f|fork)
        shift
        cmd_fork "$@"
        ;;
    d|delete|rm)
        shift
        cmd_delete "$@"
        ;;
    l|list|ls)
        cmd_list
        ;;
    h|help|--help|-h)
        show_help
        ;;
    "")
        show_help
        ;;
    *)
        echo "Unknown command: $1"
        show_help
        exit 1
        ;;
esac
